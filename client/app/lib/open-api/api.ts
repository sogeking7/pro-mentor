/* tslint:disable */
/* eslint-disable */
/**
 * Pro Mentor FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 * Schema for individual habit completion on a specific day
 * @export
 * @interface DailyHabitCompletion
 */
export interface DailyHabitCompletion {
  /**
   *
   * @type {HabitOut}
   * @memberof DailyHabitCompletion
   */
  habit: HabitOut;
  /**
   *
   * @type {boolean}
   * @memberof DailyHabitCompletion
   */
  completed: boolean;
  /**
   *
   * @type {number}
   * @memberof DailyHabitCompletion
   */
  completion_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof DailyHabitCompletion
   */
  date: string;
}
/**
 * Schema for all habits report for a specific day
 * @export
 * @interface DailyHabitsReport
 */
export interface DailyHabitsReport {
  /**
   *
   * @type {string}
   * @memberof DailyHabitsReport
   */
  date: string;
  /**
   *
   * @type {Array<DailyHabitCompletion>}
   * @memberof DailyHabitsReport
   */
  habit_completions: Array<DailyHabitCompletion>;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface HabitCompletionOut
 */
export interface HabitCompletionOut {
  /**
   *
   * @type {number}
   * @memberof HabitCompletionOut
   */
  habit_id: number;
  /**
   *
   * @type {boolean}
   * @memberof HabitCompletionOut
   */
  completed: boolean;
  /**
   *
   * @type {number}
   * @memberof HabitCompletionOut
   */
  id: number;
  /**
   *
   * @type {HabitOut}
   * @memberof HabitCompletionOut
   */
  habit: HabitOut;
  /**
   *
   * @type {string}
   * @memberof HabitCompletionOut
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof HabitCompletionOut
   */
  updated_at?: string | null;
}
/**
 *
 * @export
 * @interface HabitCompletionSave
 */
export interface HabitCompletionSave {
  /**
   *
   * @type {boolean}
   * @memberof HabitCompletionSave
   */
  completed: boolean;
}
/**
 *
 * @export
 * @interface HabitCreate
 */
export interface HabitCreate {
  /**
   *
   * @type {string}
   * @memberof HabitCreate
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof HabitCreate
   */
  habit_type_id: number;
}
/**
 *
 * @export
 * @interface HabitOut
 */
export interface HabitOut {
  /**
   *
   * @type {string}
   * @memberof HabitOut
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof HabitOut
   */
  habit_type_id: number;
  /**
   *
   * @type {number}
   * @memberof HabitOut
   */
  id: number;
  /**
   *
   * @type {HabitTypeOut}
   * @memberof HabitOut
   */
  type: HabitTypeOut;
}
/**
 *
 * @export
 * @interface HabitTypeOut
 */
export interface HabitTypeOut {
  /**
   *
   * @type {string}
   * @memberof HabitTypeOut
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof HabitTypeOut
   */
  id: number;
}
/**
 *
 * @export
 * @interface HabitUpdate
 */
export interface HabitUpdate {
  /**
   *
   * @type {string}
   * @memberof HabitUpdate
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof HabitUpdate
   */
  habit_type_id: number;
}
/**
 * Schema for the complete monthly habits report
 * @export
 * @interface MonthlyHabitsReport
 */
export interface MonthlyHabitsReport {
  /**
   *
   * @type {number}
   * @memberof MonthlyHabitsReport
   */
  year: number;
  /**
   *
   * @type {number}
   * @memberof MonthlyHabitsReport
   */
  month: number;
  /**
   *
   * @type {Array<DailyHabitsReport>}
   * @memberof MonthlyHabitsReport
   */
  daily_reports: Array<DailyHabitsReport>;
  /**
   *
   * @type {number}
   * @memberof MonthlyHabitsReport
   */
  total_days: number;
  /**
   *
   * @type {number}
   * @memberof MonthlyHabitsReport
   */
  total_habits: number;
}
/**
 *
 * @export
 * @interface PageUserOut
 */
export interface PageUserOut {
  /**
   *
   * @type {Array<UserOut>}
   * @memberof PageUserOut
   */
  items: Array<UserOut>;
  /**
   *
   * @type {number}
   * @memberof PageUserOut
   */
  total?: number | null;
  /**
   *
   * @type {number}
   * @memberof PageUserOut
   */
  page: number | null;
  /**
   *
   * @type {number}
   * @memberof PageUserOut
   */
  size: number | null;
  /**
   *
   * @type {number}
   * @memberof PageUserOut
   */
  pages?: number | null;
}
/**
 *
 * @export
 * @interface PlanOut
 */
export interface PlanOut {
  /**
   *
   * @type {string}
   * @memberof PlanOut
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof PlanOut
   */
  category_name: string;
  /**
   *
   * @type {string}
   * @memberof PlanOut
   */
  category_icon: string;
  /**
   *
   * @type {string}
   * @memberof PlanOut
   */
  date: string;
  /**
   *
   * @type {number}
   * @memberof PlanOut
   */
  id: number;
}
/**
 *
 * @export
 * @interface PlanSave
 */
export interface PlanSave {
  /**
   *
   * @type {string}
   * @memberof PlanSave
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof PlanSave
   */
  category_name: string;
  /**
   *
   * @type {string}
   * @memberof PlanSave
   */
  category_icon: string;
  /**
   *
   * @type {string}
   * @memberof PlanSave
   */
  date: string;
}
/**
 *
 * @export
 * @interface SmartOut
 */
export interface SmartOut {
  /**
   *
   * @type {string}
   * @memberof SmartOut
   */
  s: string;
  /**
   *
   * @type {string}
   * @memberof SmartOut
   */
  m: string;
  /**
   *
   * @type {string}
   * @memberof SmartOut
   */
  a: string;
  /**
   *
   * @type {string}
   * @memberof SmartOut
   */
  r: string;
  /**
   *
   * @type {string}
   * @memberof SmartOut
   */
  t: string;
  /**
   *
   * @type {number}
   * @memberof SmartOut
   */
  id: number;
}
/**
 *
 * @export
 * @interface SmartSave
 */
export interface SmartSave {
  /**
   *
   * @type {string}
   * @memberof SmartSave
   */
  s: string;
  /**
   *
   * @type {string}
   * @memberof SmartSave
   */
  m: string;
  /**
   *
   * @type {string}
   * @memberof SmartSave
   */
  a: string;
  /**
   *
   * @type {string}
   * @memberof SmartSave
   */
  r: string;
  /**
   *
   * @type {string}
   * @memberof SmartSave
   */
  t: string;
}
/**
 *
 * @export
 * @interface TokenModel
 */
export interface TokenModel {
  /**
   *
   * @type {string}
   * @memberof TokenModel
   */
  access_token: string;
  /**
   *
   * @type {string}
   * @memberof TokenModel
   */
  token_type: string;
}
/**
 *
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  first_name: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  last_name: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  email: string;
  /**
   *
   * @type {number}
   * @memberof UserCreate
   */
  user_role_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  password: string;
}
/**
 *
 * @export
 * @interface UserOut
 */
export interface UserOut {
  /**
   *
   * @type {string}
   * @memberof UserOut
   */
  first_name: string;
  /**
   *
   * @type {string}
   * @memberof UserOut
   */
  last_name: string;
  /**
   *
   * @type {string}
   * @memberof UserOut
   */
  email: string;
  /**
   *
   * @type {number}
   * @memberof UserOut
   */
  user_role_id?: number | null;
  /**
   *
   * @type {number}
   * @memberof UserOut
   */
  id: number;
  /**
   *
   * @type {UserRoleOut}
   * @memberof UserOut
   */
  role?: UserRoleOut | null;
}
/**
 *
 * @export
 * @interface UserRoleOut
 */
export interface UserRoleOut {
  /**
   *
   * @type {string}
   * @memberof UserRoleOut
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof UserRoleOut
   */
  id: number;
}
/**
 *
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  first_name: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  last_name: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  email: string;
  /**
   *
   * @type {number}
   * @memberof UserUpdate
   */
  user_role_id?: number | null;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<ValidationErrorLocInner>}
   * @memberof ValidationError
   */
  loc: Array<ValidationErrorLocInner>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}
/**
 *
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Login
     * @param {string} username
     * @param {string} password
     * @param {string | null} [grantType]
     * @param {string} [scope]
     * @param {string | null} [clientId]
     * @param {string | null} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      username: string,
      password: string,
      grantType?: string | null,
      scope?: string,
      clientId?: string | null,
      clientSecret?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("login", "username", username);
      // verify required parameter 'password' is not null or undefined
      assertParamExists("login", "password", password);
      const localVarPath = `/api/v1/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (grantType !== undefined) {
        localVarFormParams.set("grant_type", grantType as any);
      }

      if (username !== undefined) {
        localVarFormParams.set("username", username as any);
      }

      if (password !== undefined) {
        localVarFormParams.set("password", password as any);
      }

      if (scope !== undefined) {
        localVarFormParams.set("scope", scope as any);
      }

      if (clientId !== undefined) {
        localVarFormParams.set("client_id", clientId as any);
      }

      if (clientSecret !== undefined) {
        localVarFormParams.set("client_secret", clientSecret as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Register
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register: async (
      userCreate: UserCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userCreate' is not null or undefined
      assertParamExists("register", "userCreate", userCreate);
      const localVarPath = `/api/v1/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Login
     * @param {string} username
     * @param {string} password
     * @param {string | null} [grantType]
     * @param {string} [scope]
     * @param {string | null} [clientId]
     * @param {string | null} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      username: string,
      password: string,
      grantType?: string | null,
      scope?: string,
      clientId?: string | null,
      clientSecret?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        username,
        password,
        grantType,
        scope,
        clientId,
        clientSecret,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.login"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.logout"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Register
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async register(
      userCreate: UserCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenModel>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.register(
        userCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.register"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     *
     * @summary Login
     * @param {string} username
     * @param {string} password
     * @param {string | null} [grantType]
     * @param {string} [scope]
     * @param {string | null} [clientId]
     * @param {string | null} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      username: string,
      password: string,
      grantType?: string | null,
      scope?: string,
      clientId?: string | null,
      clientSecret?: string | null,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TokenModel> {
      return localVarFp
        .login(
          username,
          password,
          grantType,
          scope,
          clientId,
          clientSecret,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: RawAxiosRequestConfig): AxiosPromise<any> {
      return localVarFp
        .logout(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Register
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(
      userCreate: UserCreate,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TokenModel> {
      return localVarFp
        .register(userCreate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Login
   * @param {string} username
   * @param {string} password
   * @param {string | null} [grantType]
   * @param {string} [scope]
   * @param {string | null} [clientId]
   * @param {string | null} [clientSecret]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public login(
    username: string,
    password: string,
    grantType?: string | null,
    scope?: string,
    clientId?: string | null,
    clientSecret?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .login(
        username,
        password,
        grantType,
        scope,
        clientId,
        clientSecret,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Logout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public logout(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Register
   * @param {UserCreate} userCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public register(userCreate: UserCreate, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .register(userCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HabitsApi - axios parameter creator
 * @export
 */
export const HabitsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create User Habit
     * @param {HabitCreate} habitCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserHabit: async (
      habitCreate: HabitCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'habitCreate' is not null or undefined
      assertParamExists("createUserHabit", "habitCreate", habitCreate);
      const localVarPath = `/api/v1/habits/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        habitCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete User Habit
     * @param {number} habitId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserHabit: async (
      habitId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'habitId' is not null or undefined
      assertParamExists("deleteUserHabit", "habitId", habitId);
      const localVarPath = `/api/v1/habits/{habit_id}`.replace(
        `{${"habit_id"}}`,
        encodeURIComponent(String(habitId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Monthly Habit Completions
     * @param {number} year
     * @param {number} month
     * @param {string} [timezone] User\&#39;s timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    monthlyHabitCompletions: async (
      year: number,
      month: number,
      timezone?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists("monthlyHabitCompletions", "year", year);
      // verify required parameter 'month' is not null or undefined
      assertParamExists("monthlyHabitCompletions", "month", month);
      const localVarPath =
        `/api/v1/habits/monthly_habit_completions/{year}/{month}`
          .replace(`{${"year"}}`, encodeURIComponent(String(year)))
          .replace(`{${"month"}}`, encodeURIComponent(String(month)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      if (timezone !== undefined) {
        localVarQueryParameter["timezone"] = timezone;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read Habit Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readHabitTypes: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/habits/habit_types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read User Habits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUserHabits: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/habits/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save Habit Completion
     * @param {number} habitId
     * @param {HabitCompletionSave} habitCompletionSave
     * @param {string} [timezone] User\&#39;s timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveHabitCompletion: async (
      habitId: number,
      habitCompletionSave: HabitCompletionSave,
      timezone?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'habitId' is not null or undefined
      assertParamExists("saveHabitCompletion", "habitId", habitId);
      // verify required parameter 'habitCompletionSave' is not null or undefined
      assertParamExists(
        "saveHabitCompletion",
        "habitCompletionSave",
        habitCompletionSave,
      );
      const localVarPath =
        `/api/v1/habits/save_habit_completion/{habit_id}`.replace(
          `{${"habit_id"}}`,
          encodeURIComponent(String(habitId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      if (timezone !== undefined) {
        localVarQueryParameter["timezone"] = timezone;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        habitCompletionSave,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Today Habit Completions
     * @param {string} [timezone] User\&#39;s timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    todayHabitCompletions: async (
      timezone?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/habits/today_habit_completions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      if (timezone !== undefined) {
        localVarQueryParameter["timezone"] = timezone;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update User Habit
     * @param {number} habitId
     * @param {HabitUpdate} habitUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserHabit: async (
      habitId: number,
      habitUpdate: HabitUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'habitId' is not null or undefined
      assertParamExists("updateUserHabit", "habitId", habitId);
      // verify required parameter 'habitUpdate' is not null or undefined
      assertParamExists("updateUserHabit", "habitUpdate", habitUpdate);
      const localVarPath = `/api/v1/habits/{habit_id}`.replace(
        `{${"habit_id"}}`,
        encodeURIComponent(String(habitId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        habitUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HabitsApi - functional programming interface
 * @export
 */
export const HabitsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HabitsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create User Habit
     * @param {HabitCreate} habitCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserHabit(
      habitCreate: HabitCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HabitOut>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserHabit(
        habitCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HabitsApi.createUserHabit"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete User Habit
     * @param {number} habitId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserHabit(
      habitId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserHabit(
        habitId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HabitsApi.deleteUserHabit"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Monthly Habit Completions
     * @param {number} year
     * @param {number} month
     * @param {string} [timezone] User\&#39;s timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async monthlyHabitCompletions(
      year: number,
      month: number,
      timezone?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MonthlyHabitsReport>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.monthlyHabitCompletions(
          year,
          month,
          timezone,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HabitsApi.monthlyHabitCompletions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read Habit Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readHabitTypes(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<HabitTypeOut>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readHabitTypes(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HabitsApi.readHabitTypes"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read User Habits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readUserHabits(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<HabitOut>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readUserHabits(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HabitsApi.readUserHabits"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Save Habit Completion
     * @param {number} habitId
     * @param {HabitCompletionSave} habitCompletionSave
     * @param {string} [timezone] User\&#39;s timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveHabitCompletion(
      habitId: number,
      habitCompletionSave: HabitCompletionSave,
      timezone?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HabitCompletionOut>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.saveHabitCompletion(
          habitId,
          habitCompletionSave,
          timezone,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HabitsApi.saveHabitCompletion"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Today Habit Completions
     * @param {string} [timezone] User\&#39;s timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async todayHabitCompletions(
      timezone?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<HabitCompletionOut>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.todayHabitCompletions(
          timezone,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HabitsApi.todayHabitCompletions"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update User Habit
     * @param {number} habitId
     * @param {HabitUpdate} habitUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserHabit(
      habitId: number,
      habitUpdate: HabitUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HabitOut>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserHabit(
        habitId,
        habitUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HabitsApi.updateUserHabit"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HabitsApi - factory interface
 * @export
 */
export const HabitsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = HabitsApiFp(configuration);
  return {
    /**
     *
     * @summary Create User Habit
     * @param {HabitCreate} habitCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserHabit(
      habitCreate: HabitCreate,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<HabitOut> {
      return localVarFp
        .createUserHabit(habitCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete User Habit
     * @param {number} habitId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserHabit(
      habitId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUserHabit(habitId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Monthly Habit Completions
     * @param {number} year
     * @param {number} month
     * @param {string} [timezone] User\&#39;s timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    monthlyHabitCompletions(
      year: number,
      month: number,
      timezone?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MonthlyHabitsReport> {
      return localVarFp
        .monthlyHabitCompletions(year, month, timezone, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read Habit Types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readHabitTypes(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<HabitTypeOut>> {
      return localVarFp
        .readHabitTypes(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read User Habits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUserHabits(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<HabitOut>> {
      return localVarFp
        .readUserHabits(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Save Habit Completion
     * @param {number} habitId
     * @param {HabitCompletionSave} habitCompletionSave
     * @param {string} [timezone] User\&#39;s timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveHabitCompletion(
      habitId: number,
      habitCompletionSave: HabitCompletionSave,
      timezone?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<HabitCompletionOut> {
      return localVarFp
        .saveHabitCompletion(habitId, habitCompletionSave, timezone, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Today Habit Completions
     * @param {string} [timezone] User\&#39;s timezone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    todayHabitCompletions(
      timezone?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<HabitCompletionOut>> {
      return localVarFp
        .todayHabitCompletions(timezone, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update User Habit
     * @param {number} habitId
     * @param {HabitUpdate} habitUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserHabit(
      habitId: number,
      habitUpdate: HabitUpdate,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<HabitOut> {
      return localVarFp
        .updateUserHabit(habitId, habitUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HabitsApi - object-oriented interface
 * @export
 * @class HabitsApi
 * @extends {BaseAPI}
 */
export class HabitsApi extends BaseAPI {
  /**
   *
   * @summary Create User Habit
   * @param {HabitCreate} habitCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabitsApi
   */
  public createUserHabit(
    habitCreate: HabitCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return HabitsApiFp(this.configuration)
      .createUserHabit(habitCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete User Habit
   * @param {number} habitId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabitsApi
   */
  public deleteUserHabit(habitId: number, options?: RawAxiosRequestConfig) {
    return HabitsApiFp(this.configuration)
      .deleteUserHabit(habitId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Monthly Habit Completions
   * @param {number} year
   * @param {number} month
   * @param {string} [timezone] User\&#39;s timezone
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabitsApi
   */
  public monthlyHabitCompletions(
    year: number,
    month: number,
    timezone?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return HabitsApiFp(this.configuration)
      .monthlyHabitCompletions(year, month, timezone, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read Habit Types
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabitsApi
   */
  public readHabitTypes(options?: RawAxiosRequestConfig) {
    return HabitsApiFp(this.configuration)
      .readHabitTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read User Habits
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabitsApi
   */
  public readUserHabits(options?: RawAxiosRequestConfig) {
    return HabitsApiFp(this.configuration)
      .readUserHabits(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Save Habit Completion
   * @param {number} habitId
   * @param {HabitCompletionSave} habitCompletionSave
   * @param {string} [timezone] User\&#39;s timezone
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabitsApi
   */
  public saveHabitCompletion(
    habitId: number,
    habitCompletionSave: HabitCompletionSave,
    timezone?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return HabitsApiFp(this.configuration)
      .saveHabitCompletion(habitId, habitCompletionSave, timezone, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Today Habit Completions
   * @param {string} [timezone] User\&#39;s timezone
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabitsApi
   */
  public todayHabitCompletions(
    timezone?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return HabitsApiFp(this.configuration)
      .todayHabitCompletions(timezone, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update User Habit
   * @param {number} habitId
   * @param {HabitUpdate} habitUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HabitsApi
   */
  public updateUserHabit(
    habitId: number,
    habitUpdate: HabitUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return HabitsApiFp(this.configuration)
      .updateUserHabit(habitId, habitUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthHealthGet: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthHealthGet(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.healthHealthGet(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.healthHealthGet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     *
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
      return localVarFp
        .healthHealthGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   *
   * @summary Health
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public healthHealthGet(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .healthHealthGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PlansApi - axios parameter creator
 * @export
 */
export const PlansApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create User Plan
     * @param {PlanSave} planSave
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserPlan: async (
      planSave: PlanSave,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'planSave' is not null or undefined
      assertParamExists("createUserPlan", "planSave", planSave);
      const localVarPath = `/api/v1/plans/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        planSave,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete User Plan
     * @param {number} planId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserPlan: async (
      planId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'planId' is not null or undefined
      assertParamExists("deleteUserPlan", "planId", planId);
      const localVarPath = `/api/v1/plans/{plan_id}`.replace(
        `{${"plan_id"}}`,
        encodeURIComponent(String(planId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read User Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUserPlans: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/plans/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlansApi - functional programming interface
 * @export
 */
export const PlansApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PlansApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create User Plan
     * @param {PlanSave} planSave
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserPlan(
      planSave: PlanSave,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanOut>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserPlan(
        planSave,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PlansApi.createUserPlan"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete User Plan
     * @param {number} planId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserPlan(
      planId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserPlan(
        planId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PlansApi.deleteUserPlan"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read User Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readUserPlans(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlanOut>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readUserPlans(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["PlansApi.readUserPlans"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PlansApi - factory interface
 * @export
 */
export const PlansApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PlansApiFp(configuration);
  return {
    /**
     *
     * @summary Create User Plan
     * @param {PlanSave} planSave
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserPlan(
      planSave: PlanSave,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PlanOut> {
      return localVarFp
        .createUserPlan(planSave, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete User Plan
     * @param {number} planId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserPlan(
      planId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUserPlan(planId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read User Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUserPlans(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<PlanOut>> {
      return localVarFp
        .readUserPlans(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PlansApi - object-oriented interface
 * @export
 * @class PlansApi
 * @extends {BaseAPI}
 */
export class PlansApi extends BaseAPI {
  /**
   *
   * @summary Create User Plan
   * @param {PlanSave} planSave
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlansApi
   */
  public createUserPlan(planSave: PlanSave, options?: RawAxiosRequestConfig) {
    return PlansApiFp(this.configuration)
      .createUserPlan(planSave, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete User Plan
   * @param {number} planId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlansApi
   */
  public deleteUserPlan(planId: number, options?: RawAxiosRequestConfig) {
    return PlansApiFp(this.configuration)
      .deleteUserPlan(planId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read User Plans
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlansApi
   */
  public readUserPlans(options?: RawAxiosRequestConfig) {
    return PlansApiFp(this.configuration)
      .readUserPlans(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SmartsApi - axios parameter creator
 * @export
 */
export const SmartsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create User Smart
     * @param {SmartSave} smartSave
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserSmart: async (
      smartSave: SmartSave,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'smartSave' is not null or undefined
      assertParamExists("createUserSmart", "smartSave", smartSave);
      const localVarPath = `/api/v1/smarts/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        smartSave,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete User Smart
     * @param {number} smartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSmart: async (
      smartId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'smartId' is not null or undefined
      assertParamExists("deleteUserSmart", "smartId", smartId);
      const localVarPath = `/api/v1/smarts/{smart_id}`.replace(
        `{${"smart_id"}}`,
        encodeURIComponent(String(smartId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read User Smarts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUserSmarts: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/smarts/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SmartsApi - functional programming interface
 * @export
 */
export const SmartsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SmartsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create User Smart
     * @param {SmartSave} smartSave
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserSmart(
      smartSave: SmartSave,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartOut>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserSmart(
        smartSave,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SmartsApi.createUserSmart"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete User Smart
     * @param {number} smartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserSmart(
      smartId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserSmart(
        smartId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SmartsApi.deleteUserSmart"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read User Smarts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readUserSmarts(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SmartOut>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readUserSmarts(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SmartsApi.readUserSmarts"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SmartsApi - factory interface
 * @export
 */
export const SmartsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SmartsApiFp(configuration);
  return {
    /**
     *
     * @summary Create User Smart
     * @param {SmartSave} smartSave
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserSmart(
      smartSave: SmartSave,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SmartOut> {
      return localVarFp
        .createUserSmart(smartSave, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete User Smart
     * @param {number} smartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSmart(
      smartId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUserSmart(smartId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read User Smarts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUserSmarts(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<SmartOut>> {
      return localVarFp
        .readUserSmarts(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SmartsApi - object-oriented interface
 * @export
 * @class SmartsApi
 * @extends {BaseAPI}
 */
export class SmartsApi extends BaseAPI {
  /**
   *
   * @summary Create User Smart
   * @param {SmartSave} smartSave
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartsApi
   */
  public createUserSmart(
    smartSave: SmartSave,
    options?: RawAxiosRequestConfig,
  ) {
    return SmartsApiFp(this.configuration)
      .createUserSmart(smartSave, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete User Smart
   * @param {number} smartId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartsApi
   */
  public deleteUserSmart(smartId: number, options?: RawAxiosRequestConfig) {
    return SmartsApiFp(this.configuration)
      .deleteUserSmart(smartId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read User Smarts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartsApi
   */
  public readUserSmarts(options?: RawAxiosRequestConfig) {
    return SmartsApiFp(this.configuration)
      .readUserSmarts(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create User
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (
      userCreate: UserCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userCreate' is not null or undefined
      assertParamExists("createUser", "userCreate", userCreate);
      const localVarPath = `/api/v1/users/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      userId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteUser", "userId", userId);
      const localVarPath = `/api/v1/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCurrentUser: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/users/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUser: async (
      userId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("readUser", "userId", userId);
      const localVarPath = `/api/v1/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read User Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUserRoles: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/users/user_roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Read Users
     * @param {string | null} [q]
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUsers: async (
      q?: string | null,
      page?: number,
      size?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/users/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      if (q !== undefined) {
        localVarQueryParameter["q"] = q;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update User
     * @param {number} userId
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userId: number,
      userUpdate: UserUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("updateUser", "userId", userId);
      // verify required parameter 'userUpdate' is not null or undefined
      assertParamExists("updateUser", "userUpdate", userUpdate);
      const localVarPath = `/api/v1/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "bearerAuth",
        [],
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create User
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      userCreate: UserCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        userCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.createUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        userId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.deleteUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readCurrentUser(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readCurrentUser(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.readCurrentUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readUser(
      userId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.readUser(
        userId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.readUser"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read User Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readUserRoles(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UserRoleOut>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readUserRoles(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.readUserRoles"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Read Users
     * @param {string | null} [q]
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readUsers(
      q?: string | null,
      page?: number,
      size?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageUserOut>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.readUsers(
        q,
        page,
        size,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.readUsers"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update User
     * @param {number} userId
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userId: number,
      userUpdate: UserUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        userId,
        userUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.updateUser"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Create User
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      userCreate: UserCreate,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserOut> {
      return localVarFp
        .createUser(userCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      userId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUser(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<UserOut> {
      return localVarFp
        .readCurrentUser(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUser(
      userId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserOut> {
      return localVarFp
        .readUser(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read User Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUserRoles(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<UserRoleOut>> {
      return localVarFp
        .readUserRoles(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Read Users
     * @param {string | null} [q]
     * @param {number} [page] Page number
     * @param {number} [size] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readUsers(
      q?: string | null,
      page?: number,
      size?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PageUserOut> {
      return localVarFp
        .readUsers(q, page, size, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update User
     * @param {number} userId
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      userId: number,
      userUpdate: UserUpdate,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserOut> {
      return localVarFp
        .updateUser(userId, userUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Create User
   * @param {UserCreate} userCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUser(userCreate: UserCreate, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .createUser(userCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete User
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUser(userId: number, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .deleteUser(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Current User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public readCurrentUser(options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .readCurrentUser(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read User
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public readUser(userId: number, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .readUser(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read User Roles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public readUserRoles(options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .readUserRoles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Read Users
   * @param {string | null} [q]
   * @param {number} [page] Page number
   * @param {number} [size] Page size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public readUsers(
    q?: string | null,
    page?: number,
    size?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .readUsers(q, page, size, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update User
   * @param {number} userId
   * @param {UserUpdate} userUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateUser(
    userId: number,
    userUpdate: UserUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersApiFp(this.configuration)
      .updateUser(userId, userUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
